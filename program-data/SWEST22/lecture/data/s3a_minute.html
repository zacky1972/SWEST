<!DOCTYPE html><head><meta charset="UTF-8"><title>s3a_minute</title></head><body><p>
**********************************************************************
<br/>
セッション：S3a
<br/>
テーマ　　：Zig言語およびZen言語によるリアルタイムOSの実現
<br/>
講師　　　：高田 広章 名古屋大学
<br/>
日時　　　：2020/08/21(金) 11:30～12:40
<br/>
参加人数　：49 名
<br/>
**********************************************************************
<br/>

<br/>

<br/>
<目次>
<br/>
  ・取り組みの背景
<br/>
  ・Zig言語とZen言語の紹介
<br/>
  ・Zig言語およびZen言語によるRTOSの実現
<br/>
  ・プログラミング言語の安全性
<br/>
  ・今後の取り組みとソースコードへのアクセス
<br/>

<br/>
  
<br/>
＜取り組みの背景＞
<br/>
    ・開発する対象が複雑化するなかで開発に使用する道具も革新させていくべき
<br/>
    ・C言語のベースは古い
<br/>
         新しい言語を使いたい
<br/>
         いつが乗り換え時かは難しい
<br/>

<br/>

<br/>
＜Zig言語とZen言語の紹介＞
<br/>
    Zigとは
<br/>
       ・汎用プログラミング言語
<br/>
            OS、組込みシステム、リアルタイムシステムも想定
<br/>
       ・C言語を現代風に改良、拡張したもの
<br/>
       ・なぜZigなのか?
<br/>
            静的APIを置き換えられる可能性があるのがモチベーション
<br/>

<br/>
    他のプログラミング言語との位置付け
<br/>
        Go   : better Java/C#
<br/>
        Rust : better C++
<br/>
        Zig  : better C
<br/>

<br/>
        ・明確な違いはヒープの扱い
<br/>
            Go: ヒープありガベッジコレクション(GC)を使用する
<br/>
            Rust: ヒープあり 所有権でメモリ開放を静的に決定する
<br/>
            Zig : ヒープ必須ではない、使う場合はアロケータを呼ぶ、複数種のアロケータを利用できる
<br/>

<br/>
        ・Zigを選ぶ理由
<br/>
             組み込みシステムによるが、リアルタイムシステム的にGCは使いたくない
<br/>
             ヒープもシステムによっては利用したくない
<br/>

<br/>
        Zigの基本的な設計方針
<br/>
           隠れた制御フローが無い
<br/>
           手動のメモリ管理
<br/>
           性能と安全性の両立(ただし、メモリ安全ではない)
<br/>
               alloc、free手動なので間違えるとメモリ破壊
<br/>
           シンプルな文法
<br/>

<br/>
        Zigの特徴
<br/>
           コンパイル時のコード実行
<br/>
           安全性の向上:  ポインタの種類分け
<br/>
           記述性の向上: 新しいエラー処理がいい、メタプログラミング的記述
<br/>

<br/>

<br/>
   Zen言語について
<br/>
     詳しいことはs2a参照
<br/>
     Zigから派生した言語
<br/>
     インターフェース機能などを拡張
<br/>
     Zenのライセンス形態 :  https://zen-lang.org/ja-JP/blog/2020-08-20/
<br/>

<br/>

<br/>
<Zig言語およびZen言語によるRTOSの実現>
<br/>
   ・TOPPERS/ASP3カーネル
<br/>
       Toppersで開発しているitron系のRTOS
<br/>
       メモリ保護やマルチコアに対応していないベースカーネル
<br/>
       カーネルlibkernel.aをZxx言語で記述することに成功
<br/>
           アセンブラもインラインアセンブラで記述(.c, .Sファイルを排除)
<br/>
       コンフィギュレーション、コンフィギュレータもZxx言語で記述
<br/>
       アプリケーションとシステムサービスは修正なし
<br/>
       ビルドシステム(Makefile)も修正
<br/>

<br/>
   ・C言語とZxx言語の違い
<br/>
       ソースコードのレビューをしながら解説 (公開資料参照)
<br/>
       Zxx言語は関数の引数が変更不可
<br/>
       Zxx言語はcomptimeなどを指定することで静的、動的処理を選択できる
<br/>
          C言語のマクロ的な処理が書ける
<br/>
       Zxx言語はdeferを宣言することで特定のイベントが発生した時の処理が書ける
<br/>
           GOTOを使用したエラー処理の代わりに使える
<br/>
           try、catchな大域脱出とdeferの組み合わせで安全なエラー処理
<br/>
       Zxx言語はオプショナル型でNULLポインタの取り扱いを管理
<br/>
           代入の記述でNULLが代入可能かどうかなどを記述
<br/>

<br/>
   ・静的APIとコンフィギュレータの置き換え
<br/>
      itronではタスクやセマフォなどの使用量を設計時に決定する
<br/>
         コンフィギュレータでC言語のソースを静的に生成する
<br/>
         コンフィギュレータの文法を覚える必要がある
<br/>
      静的APIをZxx言語で記述したい
<br/>
         オブジェクトを動的に生成するサービスコードが静的に生成されることが理想
<br/>
         すべてを記述することは現状では難しいが、できるだけ記述できるようにする
<br/>
         comptimeを利用してコンパイル時にコンフィギュレーションデータを生成する
<br/>
      コンフィギュレータの実装アプローチ
<br/>
         カーネルとコンフィギュレータを個別にコンパイルし、リンカで結合
<br/>
            カーネル本体とバイナリコードはコンフィギュレーションで変化しない
<br/>
            バイナリが変わったらテストを再実行などのケースで有効
<br/>
         カーネルとコンフィギュレーションをまとめて実行
<br/>
            コンフィギュレーションが変わるとバイナリが変わる
<br/>
            最適化が利きやすい
<br/>
      
<br/>
       コンパイルオプションで両方の実装アプローチを実現した
<br/>
         
<br/>

<br/>
   ・実現したRTOSの性能評価
<br/>
      プログラムサイズ比較
<br/>
          ZigのReleaseSafeで35%程度大きい、ReleaseFast/Smallでは15%程度大きい
<br/>
          Zxxは関数を積極的にインライン展開するためコードサイズが大きくなると思われる
<br/>
      実行時間比較
<br/>
          C言語と比較して15-20%程度高速（サービスコールのact_tskを評価）
<br/>

<br/>
   ・Zxx言語の現時点での評価
<br/>
        記述性
<br/>
           綺麗に記述できる
<br/>
              エラー処理が綺麗に記述できるなど
<br/>
        性能の評価
<br/>
           コードサイズが大きくなるのは気になる
<br/>
        Zxxの課題
<br/>
          言語処理系の不具合が多い
<br/>
          ドキュメントが不足している
<br/>
          エラーメッセージが不親切
<br/>

<br/>

<br/>
<プログラミング言語の安全性>
<br/>
   ・RTOSの特性と設計
<br/>
      性能が重視される
<br/>
          組み込み用途では性能優先で危険なコードを書くことがある
<br/>
      安全でないコードを特定、局所化し集中的に検証したい
<br/>
         C言語ではMISRA-Cからの逸脱
<br/>
         Zxxでは安全でない構文要素が明示されていない
<br/>
            安全性について議論が必要
<br/>

<br/>
   ・プログラミング言語の安全性
<br/>
          安全なプログラミング言語で記述したプログラムは、ある種の不正動作をしない
<br/>
          メモリ安全 : 定義されていないメモリアクセスをしない
<br/>
               C,C++の場合 : 配列の範囲を超えたアクセスは検出されず安全でない
<br/>
               Java :  配列の範囲を超えたアクセスは検出されて例外が発生(回復可能)
<br/>
               Rust :  配列の範囲を超えたアクセスは検出されてpanicが発生(回復不可能)
<br/>

<br/>
               Zig zenはどうか?
<br/>
                  理想はコンパイル時に検出されることだが、現実的に難しい
<br/>
                  配列の範囲を超えたアクセスは検出されてpanicが発生(回復不可能)
<br/>

<br/>
          不正動作から保護されている4つのレベル
<br/>
            ・ 静的安全
<br/>
                不正動作がコンパイル時にエラーになる
<br/>
                不正動作が実行時に検出され、不正動作しないようにプログラムを書く事が強制される
<br/>
            ・ 実行時安全
<br/>
                不正動作が実行時に検出され回復可能な例外を発生させる
<br/>
                不正動作が実行時に検出され回復不可能なpanicを発生させる
<br/>

<br/>
<今後の取り組みとソースコードへのアクセス>
<br/>
  残っている項目の開発
<br/>
  ソースコードへのアクセス
<br/>
      TOPPERS/ASP3のZigによる実装
<br/>
      https://github.com/toppers/asp3_in_zig
<br/>
           
<br/>

<br/>
■まとめ
<br/>
Zxx言語を使用してRTOSを実装した。
<br/>
コードサイズ、性能の評価を行い、コードサイズで35%-15%増加、性能でほぼ同等の結果を得た 
<br/>
</p></body>
