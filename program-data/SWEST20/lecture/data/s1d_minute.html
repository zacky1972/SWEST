<!DOCTYPE html><head><meta charset="UTF-8"><title>s1d_minute</title></head><body><p>
***********************************************
<br/>
セッションS1-d 分科会
<br/>
テーマ	:mruby/cによるマルチプログラミングの概要
<br/>
講師	:田中 和明(九州工業大学)
<br/>
日時	:2018/08/30 21:00 - 22:30
<br/>
参加人数:約35名
<br/>
************************************************
<br/>

<br/>
■概要
<br/>
・マルチプログラミング
<br/>
・mrubyとmruby/c
<br/>

<br/>
	複数のプログラムを走らせたい
<br/>
	⇒普通はOSの仕事であるが、OSなしでやりたい!
<br/>
	  (OSはリッチな環境が必要で、OSのフル機能は必要ないような場面)
<br/>

<br/>

<br/>
■自己紹介
<br/>
・田中和明(九州工業大学 情報工学部)
<br/>
・教育-情報基礎、プログラミング、データ構造とアルゴリズムなどを教えている。
<br/>
	(ほとんどC言語)
<br/>
・研究-・組込みシステム(mruby、全体の7割)　
<br/>
       ・ブロックチェーン技術(をIoTで利用する)
<br/>
       ・LPWA、光学測量に関する共同研究
<br/>

<br/>
・mruby:2010年に経済産業省にお金をもらって開発した
<br/>
	オープンソースになったが、使い方が分からなかったり、そもそもツールも少
<br/>
	なくあまり使ってもらえなかった。
<br/>
	　⇒　お金をもらって、ツールを増やして、小型化にfocusし、ここ半年で
<br/>
	　　　ようやく普及してきた。
<br/>
　　　　もうすでに、製品に使われている。(数として、一番多いのはPS4のゲームソフトでの利用)
<br/>
　　　　ハードウェアではなく、システムやソフトウェアやゲームへの組込みに
<br/>
	使われて始めた。
<br/>

<br/>
　この現状でサポートできないエリア、特にIoTで重要な領域を狙ったのが、
<br/>
　mruby/cにプロジェクトになる。基本的にはmrubyと一緒。
<br/>
　VMに工夫がしてあり、非常に小型化できたり、
<br/>
　マルチプログラミングできたりする。
<br/>

<br/>

<br/>
・マルチプログラミングとは：
<br/>
	複数の機能を実装するとプログラムが複雑化する
<br/>
	　　-異なるタイミングでそれぞれの機能を動かす
<br/>
	　　-機能ごとに実装を分離
<br/>
	　　-セキュリティ
<br/>
	　　-保守性
<br/>

<br/>
	シングルでやろうとタイミングを気にする必要や、お互いを考える必要や、
<br/>
	OSの必要性がでてきて大規模になる可能性がある
<br/>

<br/>
	例:赤色LEDを1秒間隔で点滅させる（mrubyプログラム）
<br/>
	　
<br/>
	　while true do
<br/>
	　　output 0,1
<br/>
	　　sleep_ms 1000
<br/>
	　　output 0,0
<br/>
	　　sleep_ms 1000
<br/>
	　end
<br/>

<br/>
	output ： GPIO出力
<br/>
	sleep_ms ： スリープ  
<br/>

<br/>

<br/>
問題
<br/>
:赤色LEDを1秒間隔で点滅させる
<br/>
:緑色LEDを0.1秒間隔で点滅させる
<br/>

<br/>
・シングルプログラミングの場合
<br/>

<br/>
	t = 0
<br/>
	while true do
<br/>
	　# 緑色LED
<br/>
	　if t%2 == 0 then
<br/>
	　　output 7, 0
<br/>
	　else
<br/>
	　　output 7, 1
<br/>
	　end
<br/>
	　
<br/>

<br/>
	　# 赤色LED＆リセット
<br/>
	　if t == 10 then
<br/>
	　　output 0, 1
<br/>
	　elsif t >= 20 then
<br/>
	　　t = 0
<br/>
	　　output 0, 0
<br/>
	　end
<br/>
	　sleep_ms 100
<br/>
	　t += 1
<br/>
	end
<br/>

<br/>
	これは可能だが、考えるのが大変
<br/>
	　　　　　　↓
<br/>
・マルチプログラミングを実現するための技術
<br/>
	　・割込み
<br/>
	　・スレッド
<br/>
	　・マルチタスク(プロセス)
<br/>

<br/>
	これらの技術を使いつつ、簡単に実装したい→mruby/cのマルチプログラミング
<br/>

<br/>
	while true do　　　while true do
<br/>
	　output 7, 1　　　　output 7, 1
<br/>
	　sleep_ms 100       sleep_ms 100
<br/>
	　output 7, 0        output 7, 0
<br/>
	　sleep_ms 100       sleep_ms 100
<br/>
	end                end
<br/>

<br/>

<br/>
mruby/cのマルチプログラミングでは、
<br/>
VMが二つのプログラムを切り替えながら実行している
<br/>
これが本日の話題
<br/>

<br/>
＜質疑応答＞
<br/>
	質問：
<br/>
	・平行して動いているが、始まるタイミングはそこまで気にしてない？
<br/>
	回答：
<br/>
	・二つのプログラムがそれっぽく同時に動いている感じ
<br/>
	　実際には少しずつ実行を切り替えている。現実的にはタイミングの問題や排他制御が必要。
<br/>
	　今回は、各LED（GPIO）のアクセスは独立しているので、排他制御は不要
<br/>

<br/>
	　
<br/>
・mruby 
<br/>
	  -Rubyを軽量化したもの
<br/>
	　 ～Rubyにほぼ準拠しており、Rubyの開発効率を組込みソフト開発へ活かす
<br/>
	  -Rubyとの互換性を重視
<br/>
	   ～Ruby技術者が組込み開発できる
<br/>
	　-消費メモリは400KB程度
<br/>

<br/>
	割と実績がある。
<br/>

<br/>
	mrubyの利用事例:ネットラークル−タ(IIJ社)
<br/>
	         ゲーム(スクエアエニックス、SidMeier's)
<br/>
	         Apacheモジュール(OSS)
<br/>
	         ETロボコン(アフレル社、ほか)
<br/>
	         GUIライブラリ(ILC社)
<br/>

<br/>
	＜質疑応答＞
<br/>
	質問：
<br/>
	・なんでmrubyは利用されたのか?
<br/>
	回答：
<br/>
	・modmruby:Rubyでやりたかったがでかいので、軽いmrubyが導入された
<br/>
	・ルータ:軽いmrubyがオープンソース化されて採用された。ルータの設定などで使う
<br/>
	・ゲーム:業界がスプリクト言語をほしがってた。
<br/>
	　　　     外注との言語を切り分けたいため（影響範囲を限定したい）。
<br/>

<br/>
・mruby/c
<br/>
	　-mrubyをさらに軽量化したもの ～40KB程度
<br/>
	　ワンチップマイコンでの動作を想定したもののため、資源が限られる
<br/>
	　　(実際には20KBぐらいで動く、あとはプログラムが消費するメモリに依存する)
<br/>
	　　(最小、例えば hello world であれば、10KB程度でも動く)
<br/>
	　-Rubyとの互換性というよりもrubyっぽいものを考えており、
<br/>
	　小型化を重視している。
<br/>
	  -最小限のクラスライブラリしか実装されてないため、サポートされてない
<br/>
	　Rubyの機能は多数ある
<br/>
	  -OSを必要としない
<br/>

<br/>
	＜質疑応答＞
<br/>
	質問：
<br/>
	・実装するかどうかの判断の基準は?
<br/>
	回答：
<br/>
	・基準は特にない。依頼があれば検討して実装するか判断する。
<br/>
	　個人に依存する。
<br/>
	　
<br/>
	質問：
<br/>
	・コンパイラによる最適化は難しい?
<br/>
	回答：
<br/>
	・mrubyとmruby/cのコンパイラは同じで、まつもとさんに聞いてほしい。
<br/>

<br/>

<br/>
rubyがソースコードをそのままインタプリターのかけて実行するのに対し、
<br/>
mrubyとmruby/cはソースコードをコンパイルし、mrubyバイトコードとし、
<br/>
それぞれのVMで実行させる。これによりメモリを抑えることができる。
<br/>
mruby VMとmruby/c VMは動きは一緒、サポートされるクラスやメソッドなどが違う
<br/>
 
<br/>

<br/>
■mruby/cのポイント
<br/>

<br/>
・OSを必要としない
<br/>
	・OSが提供する機能を持つ
<br/>
	　-マルチプログラミング
<br/>
	　 複数プログラムのコンカレント実行
<br/>
	　-メモリ管理
<br/>
	　-排他制御
<br/>
	・ユーザプログラムとして実行する(特権命令は必要ない)
<br/>

<br/>
・mrubyのバイトコード
<br/>
　	→ソースコードのコンパイルにより生成される。
<br/>
　　　　　　　　　   アセンブリに近い言語
<br/>
                     各レジスタはオブジェクトのインスタンスが入る
<br/>
　　　　　　　　　　 SEND（C言語の関数呼び出し）:メッセージパッシングを行う
<br/>

<br/>
　	このコードは機種に依存しないのでどのデバイスでも動く。
<br/>

<br/>
・mruby VM
<br/>
	VMがバイトコードを実行する。
<br/>
	VMを作ればどこでも実行することができる。
<br/>

<br/>
	mruby/c VMのアイデア
<br/>
	・複数のプログラム(複数のバイトコード)を実行する。
<br/>

<br/>
	loop do
<br/>
	　for i=1 to N do
<br/>
	　　current_program = program[i]
<br/>
	　　instruction = Fetch(current_program)
<br/>
	　　Execute(instruction)
<br/>
	　end
<br/>
	end
<br/>

<br/>
	1命令ごとに実行プログラムをスイッチ。可能だがオーバヘッドが大きくなるのでやらない。
<br/>
	実行効率の問題
<br/>

<br/>
	・実行効率が悪いので、
<br/>
	　いくつかのバイトコードを実行する。
<br/>

<br/>
	loop do
<br/>
	　for i=1 to N do
<br/>
	　　current_program = program[i]
<br/>
	　　for j=1 to M do
<br/>
	　　　instruction = Fetch(current_program)
<br/>
	　　　Execute(instruction)
<br/>
	　　end
<br/>
	　end
<br/>
	end
<br/>

<br/>
	パフォーマンスは上がる
<br/>
	問題：実行の公平性が保証されない（命令ごとに実行時間が異なるから）
<br/>

<br/>

<br/>
・実行の公平性
<br/>
	・プログラム間で実行時間が公平ではない。
<br/>
	　時間が来たら切り替える→ある程度の公平性は保たれる
<br/>

<br/>
	loop do
<br/>
	　for i=1 to N do
<br/>
	　　current_program = program[i]
<br/>
	　　start_time = GetCurrentTime()
<br/>
	　　while GetCurrentTime() < (start_time + TIME_SLICE) do
<br/>
	　　　instruction = Fetch(current_program)
<br/>
	　　　Execute(instruction)
<br/>
	　　end
<br/>
	　end
<br/>
	end
<br/>

<br/>
	しかし、これは重い（時刻の取得が重い！）。あくまで仮想的なプログラム。
<br/>
	そのため、、
<br/>

<br/>
・mruby/cの実装では、
<br/>
	・タイマー割込みが使える場合は、
<br/>
	　割込みでプログラムを切り替える。
<br/>

<br/>
	割り込み発生時に、実行中のプログラムの flag に1を入れる
<br/>
	⇒次の命令を実行する前にフラグをチェックする
<br/>
	⇒切り替わる
<br/>

<br/>
	この処理は軽い
<br/>

<br/>
	Result
<br/>
	・Execution time
<br/>
	 -Calculate 32th Fibonacci number using recursion
<br/>
	複数のフィボナッチ数計算をコンカレントに実行している
<br/>
	割込みだと単体(フルパフォーマンス)と同じような結果が得られた。
<br/>

<br/>
・サンプルプログラムの紹介
<br/>
	 
<br/>
	 スイッチが押されると状態が変化する
<br/>
	  0⇒１⇒0⇒１→0→１ 
<br/>
	 スイッチが押されてから500msは入力を無視する
<br/>
	 状態に応じてLEDの点滅をする
<br/>
	 
<br/>
	 シングルプログラムで考えると難しい。
<br/>
	 → 2つのプログラムにすると簡単
<br/>

<br/>
	(1) スイッチが押されたら、状態を変化させる（同時に500msの入力禁止＝プログラムのスリープ）
<br/>
	(2) 状態に応じてLEDを点滅させる
<br/>
	 
<br/>
	 状態0:50msの点滅
<br/>
	 状態1:500msの点滅
<br/>
	 状態2:1sの点滅
<br/>

<br/>
	＜質疑応答＞
<br/>
	質問：
<br/>
	・状態が変わったとき、点滅の途中はどうするか?
<br/>
	回答：
<br/>
	・排他制御とかを入れるとか、、、
<br/>
		⇒ コメント：使いにくそう、、、
<br/>
	・global変数によってプログラム間の通信ができる。
<br/>
	　アトミックにできるため排他制御は必要ない。
<br/>
	　これが現状のmruby/c
<br/>

<br/>

<br/>
	質問：
<br/>
	・優先度があればどう動くかがわかるのでは?
<br/>
	  少しコードを入れると、優先度スケジューリングできそう
<br/>
	回答：
<br/>
	・2個以上の場合、優先度がないとどうなるかわからなそう、、、
<br/>
	　シンプルさはどこまで保たれるのか
<br/>
		⇒rubyを使うぐらいには保たれる
<br/>
	　　　　　VM‎に負担があるいくだけだから
<br/>

<br/>

<br/>
	指摘:ドキュメントがない
<br/>

<br/>

<br/>
■まとめ
<br/>
なし
<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>
</p></body>
